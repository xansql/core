import Schema from "."
import { escapeSqlValue, iof, quote } from "../../utils"
import XqlArray from "../../xt/fields/Array"
import XqlBoolean from "../../xt/fields/Boolean"
import XqlDate from "../../xt/fields/Date"
import XqlEnum from "../../xt/fields/Enum"
import XqlFile from "../../xt/fields/File"
import XqlIDField from "../../xt/fields/IDField"
import XqlNumber from "../../xt/fields/Number"
import XqlObject from "../../xt/fields/Object"
import XqlRecord from "../../xt/fields/Record"
import XqlSchema from "../../xt/fields/Schema"
import XqlString from "../../xt/fields/String"
import XqlTuple from "../../xt/fields/Tuple"
import XqlUnion from "../../xt/fields/Union"
import { XqlField } from "../../xt/types"
import Xansql from "../Xansql"
import XansqlError from "../XansqlError"

export type MigrationFieldInfo = {
   type: string,
   length: number,
   default: any,
   unique: boolean,
   nullable: boolean,
   index: string
}

class Migration<S extends Schema = Schema> {

   private _info: Record<string, MigrationFieldInfo> = {}
   private _sqls: Record<string, string> = {}

   get info() {
      return this._info
   }

   get sqls() {
      return this._sqls
   }

   get createTableSQL() {
      const columnsSql = Object.values(this._sqls).join(",\n  ")
      return `CREATE TABLE IF NOT EXISTS ${quote(this.xansql.dialect.engine, this.schema.table)} (\n  ${columnsSql}\n);`
   }

   constructor(private xansql: Xansql, private schema: S) {
      const shape = schema.schemaShape as ReturnType<S["schema"]>
      for (let column in shape) {
         const field = shape[column] as XqlField
         if (field.type === "relation-one") continue; // skip relation-one fields, they will be handled in the target schema
      }
   }

   private buildField(column: string, field: XqlField) {
      const engine = this.xansql.dialect.engine;
      const table = this.schema.table;
      const meta = field.meta || {};
      const nullable = meta.nullable || meta.optional ? 'NULL' : 'NOT NULL';
      const unique = meta.unique ? 'UNIQUE' : '';

      let default_value = ''
      if (meta.default !== undefined) {
         try {
            default_value = field.parse(undefined)
         } catch (error) { }
      }

      const col = (sqlType: string) => {
         let def = default_value ? ` DEFAULT ${default_value} ` : ''
         let sql = `${quote(engine, column)} ${sqlType} ${nullable}${def}${unique}`.trim().replace(/ +/g, ' ');
         this._sqls[column] = sql
      };

      this._info[column] = {
         type: field.constructor.name,
         length: meta.length || meta.max || null,
         default: default_value || null,
         unique: meta.unique ? true : false,
         nullable: !!meta.nullable,
         index: meta.primary ? 'PRIMARY' : (meta.index ? 'INDEX' : '')
      }

      let sql = ''
      let typeSql = ''
      if (iof(field, XqlIDField)) {
         if (engine === 'mysql') {
            col("BIGINT AUTO_INCREMENT PRIMARY KEY");
         } else if (engine === 'postgresql') {
            col("BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY")
         } else if (engine === 'sqlite') {
            col("INTEGER PRIMARY KEY AUTOINCREMENT")
         }
      } else if (iof(field, XqlSchema)) {
         if (engine === 'mysql' || engine === 'postgresql') {
            col("BIGINT")
         } else if (engine === 'sqlite') {
            col("INTEGER")
         }
      } else if (iof(field, XqlString)) {
         let length = meta.length || meta.max
         if (meta.text || length > 65535 || engine === 'sqlite') {
            col("TEXT")
         } else {
            col(`VARCHAR(${length || 255})`)
         }
      } else if (iof(field, XqlFile)) {
         col("VARCHAR(255)")
      } else if (iof(field, XqlNumber)) {
         if (meta.float) {
            if (engine === "mysql") {
               col("FLOAT")
            } else {
               col("REAL")
            }
         } else if (meta.integer) {
            col("INTEGER")
         } else if (meta.bigint) {
            if (engine === "mysql" || engine === "postgresql") {
               col("BIGINT")
            } else {
               col("INTEGER")
            }
         } else if (meta.decimal) {
            if (engine === "mysql" || engine === "sqlite") {
               col(`DECIMAL(${meta.decimal.precision}, ${meta.decimal.scale})`)
            } else {
               col(`NUMERIC(${meta.decimal.precision}, ${meta.decimal.scale})`)
            }
         } else if (meta.double) {
            if (engine === "mysql") {
               col(`DOUBLE`)
            } else if (engine === "postgresql") {
               col(`DOUBLE PRECISION`)
            } else {
               col(`REAL`)
            }
         } else {
            if (engine === "sqlite") {
               col("INTEGER")
            } else {
               col("BIGINT")
            }
         }
      } else if (iof(field, XqlBoolean)) {
         if (engine === "mysql" || engine === "postgresql") {
            col("BOOLEAN")
         } else {
            col("INTEGER CHECK(column IN (0,1))") // SQLite has no BOOLEAN â†’ use INTEGER (0/1)
         }
      } else if (iof(field, XqlDate)) {
         if (engine === "mysql") {
            col("DATETIME")
         } else if (engine === "postgresql") {
            col("TIMESTAMP")
         } else {
            col("TEXT") // store ISO string (SQLite has no native DATETIME)
         }
      } else if (iof(field, XqlEnum)) {
         let options = (field as any).options
         const valuesList = options.map((v: any) => `'${escapeSqlValue(v)}'`).join(', ');
         col(`VARCHAR(255) CHECK(${quote(engine, column)} IN (${valuesList}))`)
      } else if (iof(field, XqlArray, XqlObject, XqlRecord, XqlTuple, XqlUnion)) {
         col("TEXT")
      } else {
         throw new XansqlError({
            message: `Unsupported field type for column "${column}" in table "${table}".`,
            model: table,
            column
         });
      }


      return { sql, typeSql };
   }
}

export default Migration