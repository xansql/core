import XansqlError from "../core/XansqlError";
import { escapeSqlValue, iof, quote } from "../utils";
import XqlArray from "./fields/Array";
import XqlBoolean from "./fields/Boolean";
import XqlDate from "./fields/Date";
import XqlEnum from "./fields/Enum";
import XqlFile from "./fields/File";
import XqlIDField from "./fields/IDField";
import XqlNumber from "./fields/Number";
import XqlObject from "./fields/Object";
import XqlRecord from "./fields/Record";
import XqlRelationOne from "./fields/RelationOne";
import XqlString from "./fields/String";
import XqlTuple from "./fields/Tuple";
import XqlUnion from "./fields/Union";
import { XqlField } from "./types";

export type XqlFieldInfoSchema = {
   type: string,
   length: number | null,
   default: any,
   unique: boolean,
   nullable: boolean,
   index: string | null
}

class XqlFieldInfo {
   readonly schema: XqlFieldInfoSchema
   readonly sql: {
      column: string,
      alter_column: string,
      drop_column: string;
      create_index: string
      drop_index: string
   }

   constructor(field: XqlField) {

      const table = (field as any).table
      const column = (field as any).column_name
      const engine = (field as any).engine

      const meta = field.meta || {};
      const nullable = meta.nullable || meta.optional ? 'NULL ' : 'NOT NULL ';
      const unique = meta.unique ? 'UNIQUE ' : '';

      let default_value = ''
      if (meta.default !== undefined) {
         try {
            default_value = field.parse(undefined)
         } catch (error) { }
      }


      let type = ""

      if (iof(field, XqlRelationOne)) {
         if (engine === 'mysql' || engine === 'postgresql') {
            type = "BIGINT"
         } else if (engine === 'sqlite') {
            type = "INTEGER"
         }
      } else if (iof(field, XqlIDField)) {
         if (engine === 'mysql') {
            type = "BIGINT AUTO_INCREMENT PRIMARY KEY"
         } else if (engine === 'postgresql') {
            type = "BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY"
         } else if (engine === 'sqlite') {
            type = "INTEGER PRIMARY KEY AUTOINCREMENT"
         }
      } else if (iof(field, XqlString)) {
         let length = meta.length || meta.max
         if (meta.text || length > 65535 || engine === 'sqlite') {
            type = "TEXT"
         } else {
            type = `VARCHAR(${length || 255})`
         }
      } else if (iof(field, XqlFile)) {
         type = "VARCHAR(255)"
      } else if (iof(field, XqlNumber)) {
         if (meta.float) {
            if (engine === "mysql") {
               type = "FLOAT"
            } else {
               type = "REAL"
            }
         } else if (meta.integer) {
            type = "INTEGER"
         } else if (meta.bigint) {
            if (engine === "mysql" || engine === "postgresql") {
               type = "BIGINT"
            } else {
               type = "INTEGER"
            }
         } else if (meta.decimal) {
            if (engine === "mysql" || engine === "sqlite") {
               type = `DECIMAL(${meta.decimal.precision}, ${meta.decimal.scale})`
            } else {
               type = `NUMERIC(${meta.decimal.precision}, ${meta.decimal.scale})`
            }
         } else if (meta.double) {
            if (engine === "mysql") {
               type = `DOUBLE`
            } else if (engine === "postgresql") {
               type = `DOUBLE PRECISION`
            } else {
               type = `REAL`
            }
         } else {
            if (engine === "sqlite") {
               type = "INTEGER"
            } else {
               type = "BIGINT"
            }
         }
      } else if (iof(field, XqlBoolean)) {
         type = "SMALLINT"
         default_value = default_value ? "1" : "0"
      } else if (iof(field, XqlDate)) {
         if (engine === "mysql") {
            type = "DATETIME(3)"               // supports milliseconds
         } else if (engine === "postgresql") {
            type = "TIMESTAMP(3) WITH TIME ZONE" // best practice in PG
         } else if (engine === "sqlite") {
            type = "TEXT" // store ISO 8601 string
         }
      } else if (iof(field, XqlEnum)) {
         let options = field.enum_options
         const valuesList = options.map((v: any) => `'${escapeSqlValue(v)}'`).join(', ');
         type = `VARCHAR(255) CHECK(${quote(engine, column)} IN (${valuesList}))`
      } else if (iof(field, XqlArray, XqlObject, XqlRecord, XqlTuple, XqlUnion)) {
         type = "TEXT"
      } else {
         throw new XansqlError({
            code: "QUERY_ERROR",
            message: `Unsupported field type for column "${column}" in table "${table}".`,
            model: table,
            field: column
         });
      }

      this.schema = {
         type: field.constructor.name,
         length: meta.length || meta.max || null,
         default: default_value || undefined,
         unique: meta.unique ? true : false,
         nullable: !!meta.nullable,
         index: meta.index ? `${table}_${column}_index` : ""
      }

      let create_index = ''
      if (this.schema.index) {
         create_index = `CREATE INDEX ${this.schema.index} ON ${quote(engine, table)} (${quote(engine, column)});`
         if (unique) {
            create_index = `CREATE UNIQUE INDEX ${this.schema.index} ON ${quote(engine, table)} (${quote(engine, column)});`
         }
      }
      const _column = `${quote(engine, column)} ${type} ${nullable}${default_value ? ` DEFAULT ${default_value} ` : ''}${unique}`.trim().replace(/ +/g, ' ')
      this.sql = {
         column: _column,
         alter_column: `ALTER TABLE ${field.table} ADD COLUMN ${_column}`,
         drop_column: `ALTER TABLE ${field.table} DROP COLUMN ${quote(engine, column)}`,
         create_index: create_index,
         drop_index: this.schema.index ? `DROP INDEX ${quote(engine, this.schema.index)};` : ''
      }

   }
}

export default XqlFieldInfo